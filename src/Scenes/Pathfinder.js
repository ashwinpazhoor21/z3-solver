window.global = window;
var my = { sprite: {} };
import { init } from 'z3-solver';

class Pathfinder extends Phaser.Scene {
    constructor() {
        super("pathfinderScene");
    }

    async preload() {
        // Load the tileset image and other assets here
        this.load.image("kenney-tiny-town", "./assets/tilemap_packed.png"); // Replace with the correct path
    }

    async create() {
        // Wait for random location to be generated before proceeding
        this.randomLocation = await this.generateRandomLocationWheelBarrow();

        // Ensure that `randomLocation` has a valid location to place
        if (!this.randomLocation) {
            console.error("Random location was not generated.");
            return;
        }

        console.log(this.randomLocation);
        var xLocWB = (this.randomLocation)[0];
        var yLocWB = (this.randomLocation)[1];

        console.log("X location: " + xLocWB + "    Y location: " + yLocWB);
        
        // Create a 2D array filled with zeros for procedural elements
        var proceduralElements = Array.from({ length: 25 }, () => Array(40).fill(-1));
        
        // Place the Z3-generated random location
        proceduralElements[yLocWB][xLocWB] = 57;

        console.log(proceduralElements);

        // Create a new tilemap with procedural data
        const mapPCG = this.make.tilemap({ data: proceduralElements, tileWidth: 16, tileHeight: 16 });

        // Add tileset image to map and create the main layer
        const tilesheetPCG = mapPCG.addTilesetImage("kenney-tiny-town", "kenney-tiny-town");
        this.proceduralElementsLayer = mapPCG.createLayer(0, tilesheetPCG, 0, 0);

        // Set camera bounds based on the tilemap dimensions
        this.cameras.main.setBounds(0, 0, mapPCG.widthInPixels, mapPCG.heightInPixels);

        // Create the static tilemap with predefined layers
        this.map = this.add.tilemap("three-farmhouses", this.TILESIZE, this.TILESIZE, this.TILEWIDTH, this.TILEHEIGHT);
        this.tileset = this.map.addTilesetImage("kenney-tiny-town", "kenney-tiny-town");

        // Create additional layers using the tilemap data
        this.groundLayer = this.map.createLayer("Ground-n-Walkways", this.tileset, 0, 0);
        this.treesLayer = this.map.createLayer("Trees-n-Bushes", this.tileset, 0, 0);
        this.housesLayer = this.map.createLayer("Houses-n-Fences", this.tileset, 0, 0);

        this.proceduralElementsLayer.setDepth(3);

        // Place townsfolk sprite on the map
        my.sprite.purpleTownie = this.add.sprite(this.tileXtoWorld(5), this.tileYtoWorld(5), "purple").setOrigin(0, 0);

        // Adjust camera settings for the main map
        this.cameras.main.setZoom(this.SCALE);
        this.cameras.main.setBounds(0, 0, this.map.widthInPixels, this.map.heightInPixels);
    }

    async generateRandomLocationWheelBarrow() {
        const { Context } = await init();
        const { Solver, Int, And, Or } = new Context("main");
        
        const solver = new Solver();
        const x = Int.const('x');
        const y = Int.const('y');
        const possibleLocations = [];

        solver.add(
            Or(
                And(x.gt(21), x.lt(29), y.gt(17), y.lt(20)),
                And(x.gt(34), x.lt(38), y.gt(2), y.lt(6))
            )
        );

        if (await solver.check() === 'sat') {
            while (await solver.check() === 'sat') {
                const model = solver.model();
                const xVal = parseInt(model.eval(x).toString());
                const yVal = parseInt(model.eval(y).toString());
                possibleLocations.push([xVal, yVal]);
                solver.add(Or(x.neq(xVal), y.neq(yVal)));
            }
        } else {
            console.log("No solution found: the constraints may be contradictory.");
        }

        // Select a random location from the possible locations
        const randInt = Math.floor(Math.random() * possibleLocations.length);
        console.log("Random Location generated by Z3: " + possibleLocations[randInt]);

        return possibleLocations[randInt];
    }

    tileXtoWorld(tileX) {
        return tileX * this.TILESIZE;
    }

    tileYtoWorld(tileY) {
        return tileY * this.TILESIZE;
    }
}

export default Pathfinder;